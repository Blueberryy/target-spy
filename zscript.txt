version "3.2.0"

/* Copyright Alexander Kromm (mmaulwurff@gmail.com) 2018
 *
 * This file is part of Target Spy.
 *
 * Target Spy is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Target Spy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Target Spy.  If not, see <https://www.gnu.org/licenses/>.
 */

class TSZScriptHelper : Actor
{
  static void SendResultString(PlayerInfo player, string result)
  {
    if (!player) { return; }
    CVar messageCVar = CVar.GetCVar("m8f_ts_ResultString", player);
    if (messageCVar) { messageCVar.SetString(result); }
  }

  static void SendResultInt(PlayerInfo player, int result)
  {
    if (!player) { return; }
    CVar messageCVar = CVar.GetCVar("m8f_ts_ResultInt", player);
    if (messageCVar) { messageCVar.SetInt(result); }
  }

  static void TargetIsPresent(Actor a)
  {
    if (!a) { return; }

    Actor target    = GetTarget(a);
    bool  isPresent = (target != null);

    if (isPresent) { m8f_ts_TargetCache.Get().lastTarget = target; }

    SendResultInt(a.player, isPresent);
  }

  static void GetTargetHealth(Actor a)
  {
    if (!a) { return; }

    Actor target = GetTarget(a);
    if (target == null) { SendResultInt(a.player, 0); return; }

    int targetHealth = target.Health;
    SendResultInt(a.player, targetHealth);
  }

  static void GetTargetMaxHealth(Actor a)
  {
    if (!a) { return; }

    Actor target = GetTarget(a);
    if (target == null) { SendResultInt(a.player, 0); return; }

    if (!target.bSHOOTABLE)
      {
        SendResultInt(a.player, 0);
        return;
      }

    int targetMaxHealth = target.SpawnHealth();
    SendResultInt(a.player, targetMaxHealth);
  }

  static string AddAdditionalInfo(Actor a, Actor target, string name)
  {
    Inventory inv = Inventory(target);
    if (inv)
      {
        int amount = inv.amount;
        if (amount == 1)
          {
            BasicArmorPickup armor = BasicArmorPickup(inv);
            if (armor) { amount = armor.SaveAmount; }
          }
        if (amount == 1) { return name; }
        else             { return StringStruct.Format("%s (%i)", name, amount); }
      }
    else
      {
        return PrependChampionColor(a, target, name);
      }
  }

  static string PrependChampionColor(Actor a, Actor target, string name)
  {
    if (!a) { return name; }
    PlayerInfo player =  a.player;
    if (!player) { return name; }

    bool showChampion = CVar.GetCVar("m8f_ts_show_champion", player).GetInt();
    if (!showChampion) { return name; }

    static const string championTokens[] =
      {
        "champion_BlackToken"     , "Brutal",
        "champion_BlueToken"      , "Retaliating",
        "champion_BronzeToken"    , "Tough",
        "champion_CyanToken"      , "Vortex",
        "champion_DarkGreenToken" , "Toxic",
        "champion_DarkRedToken"   , "Reanimating",
        "champion_GoldToken"      , "Golden",
        "champion_GreenToken"     , "Phasing",
        "champion_GreyToken"      , "Nimble",
        "champion_IndigoToken"    , "Fissile",
        "champion_OrangeToken"    , "Exploding",
        "champion_PinkToken"      , "Healer",
        "champion_RedToken"       , "Sturdy",
        "champion_SilverToken"    , "Reflective",
        "champion_VioletToken"    , "Relentless",
        "champion_WhiteToken"     , "Restraining",
        "champion_YellowToken"    , "Fast"
      };
    int size = 17;

    string tokenClass = "champion_Token";
    Inventory token = target.FindInventory(tokenClass, true);
    if (!token) { return name; }

    string tokenClassName = token.GetClassName();
    string championColor  = "Champion"; // default, if token is not found

    // binary search
    int L = 0;
    int R = size - 1;
    while (L <= R)
      {
        int m = (L + R) / 2;
        string current = championTokens[m * 2];
        if      (current <  tokenClassName) { L = m + 1; continue; }
        else if (current >  tokenClassName) { R = m - 1; continue; }
        else if (current == tokenClassName)
          {
            championColor = championTokens[m * 2 + 1];
            championColor.AppendFormat(" %s", name);
            return championColor;
          }
      }

    return championColor;
  }

  static void GetTargetName(Actor a, bool isFreedoom)
  {
    if (!a) { return; }
    PlayerInfo player =  a.player;
    if (!player) { return; }

    // must be sorted!
    // when you add new lines, don't forget to update the size below!
    static const string specialNames[] =
      {
        "Arachnotron_free"      , "Technospider",
        "Archvile"              , "Arch-vile",
        "Archvile_free"         , "Flame Bringer",
        "BD_Arachnotron"        , "Arachnotron",
        "BD_ArchVile"           , "Arch-vile",
        "BD_BaronOfHell"        , "Baron Of Hell",
        "BD_Cacodemon"          , "Cacodemon",
        "BD_ChaingunGuy"        , "Chaingunner",
        "BD_CyberDemon"         , "Cyberdemon",
        "BD_Demon"              , "Demon",
        "BD_DoomImp"            , "Imp",
        "BD_Fatso"              , "Mancubus",
        "BD_HellKnight"         , "Hell Knight",
        "BD_LostSoul"           , "Lost Soul",
        "BD_PainElemental"      , "Pain Elemental",
        "BD_Revenant"           , "Revenant",
        "BD_ShotgunGuy"         , "Sergeant",
        "BD_Spectre"            , "Spectre",
        "BD_SpiderMastermind"   , "Spider Mastermind",
        "BD_WolfensteinSS"      , "Wolfenstein SS",
        "BaronOfHell_free"      , "Pain Lord",
        "Cacodemon_free"        , "Trilobite",
        "ChaingunGuy"           , "Chaingunner",
        "ChaingunGuy_free"      , "Minigun Zombie",
        "CommanderKeen_free"    , "Alien Spawn",
        "Cyberdemon_free"       , "Assault Tripod",
        "Demon_free"            , "Flesh Worm",
        "DoomImp"               , "Imp",
        "DoomImp_free"          , "Serpentipede",
        "EVPArachnotron"        , "Arachnotron",
        "EVPArchVile"           , "Arch-vile",
        "EVPBaron"              , "Baron Of Hell",
        "EVPCacodemon"          , "Cacodemon",
        "EVPChaingunner"        , "Chaingunner",
        "EVPCyberdemon"         , "Cyberdemon",
        "EVPDemon"              , "Demon",
        "EVPHellKnight"         , "Hell Knight",
        "EVPImp"                , "Imp",
        "EVPLostSoul"           , "Lost Soul",
        "EVPMancubus"           , "Mancubus",
        "EVPPainElemental"      , "Pain Elemental",
        "EVPRevenant"           , "Revenant",
        "EVPShotgunner"         , "Sergeant",
        "EVPSpectre"            , "Spectre",
        "EVPSpiderMastermind"   , "Spider Mastermind",
        "Fatso"                 , "Mancubus",
        "Fatso_free"            , "Combat Slug",
        "LostSoul_free"         , "Deadflare",
        "PainElemental_free"    , "Summoner",
        "Revenant_free"         , "Dark Soldier",
        "ShotgunGuy"            , "Sergeant",
        "ShotgunGuy_free"       , "Shotgun Zombie",
        "SpiderMastermind_free" , "Large Technospider",
        "WolfensteinSS_free"    , "Sailor",
        "ZombieMan_free"        , "Zombie"
      };
    int size = 55;

    // protect agains no target
    Actor target = GetTarget(a);
    if (target == null) { SendResultString(player, "unknown"); return; }

    string targetClass = target.GetClassName();

    bool showInternalNames = CVar.GetCVar("m8f_class_as_tag", player).GetInt();
    if (showInternalNames) { SendResultString(player, targetClass); return; }

    // to give Freedoom monsters special names
    if (isFreedoom) { targetClass.AppendFormat("_free"); }

    // if target name was found before, just return it
    let cache = TagCache.Get();
    if (cache.cachedClass == targetClass)
      {
        SendResultString(player, AddAdditionalInfo(a, target, cache.cachedTag));
        return;
      }

    // if target name is set via actor tag, return it
    string targetName = target.GetTag();
    if (targetName != targetClass)
      {
        cache.SetCache(targetClass, targetName);
        SendResultString(player, AddAdditionalInfo(a, target, targetName));
        return;
      }

    // try to find target tag in override list
    // binary search
    int L = 0;
    int R = size - 1;
    while (L <= R)
      {
        int m = (L + R) / 2;
        string current = specialNames[m * 2];
        if      (current <  targetClass) { L = m + 1; continue; }
        else if (current >  targetClass) { R = m - 1; continue; }
        else if (current == targetClass)
          {
            targetName = specialNames[m * 2 + 1];
            cache.SetCache(targetClass, targetName);
            SendResultString(player, AddAdditionalInfo(a, target, targetName));
            return;
          }
      }

    // if target name is not found, compose tag from class name
    targetName = SeparateCamelCase(targetName);
    targetName.Replace("_", " ");

    cache.SetCache(targetClass, targetName);
    SendResultString(player, AddAdditionalInfo(a, target, targetName));
  }

  static Actor GetTarget(Actor a)
  {
    static const string blackList[] =
      {
        "m8f_aas_token",
        "AutoautosaveToken",
        "AutoautosaveAlertToken",
        "AutoautosaveAlerter",
        "AutoautosaveBossAlerter",
        "UGGib_Corpse_Shootable",
        "VoidField"
      };
    int blackListSize = 7;

    let player = a.player;
    if (!player) { return null; }

    // try an easy way to get a target (also works with autoaim)
    Actor target = player.mo.AimTarget();

    // if target is not found by easy way, try the difficult way
    if (target == null)
      {
        FTranslatedLineTarget victimTarget;
        a.LineAttack(a.angle, 4000.0, a.pitch, 0, "none",
                     "m8f_ts_InvisiblePuff", LAF_NOIMPACTDECAL, victimTarget);
        target = victimTarget.linetarget;
      }

    int showObjects = CVar.GetCVar("m8f_ts_show_objects", player).GetInt();

    if (target == null && showObjects > 1)
      {
        FTranslatedLineTarget ftlt;
        a.AimLineAttack(a.angle, 2048.0, ftlt, 0,
                        ALF_CHECKNONSHOOTABLE | ALF_FORCENOSMART);
        target = ftlt.linetarget;
      }

    // give up
    if (target == null) { return null; }

    for (int i = 0; i < blackListSize; ++i)
      {
        if (target is blackList[i]) { return null; }
      }

    if (target.bISMONSTER)
      {
        if (target.bSHADOW || target.bSTEALTH)
          {
            bool showHidden = CVar.GetCVar("m8f_ts_show_hidden", player).GetInt();
            if (!showHidden) { return null; }
          }
      }
    else // not monsters
      {
        switch (showObjects)
          {
          case 0: return null;
          case 1:
            if (target.bSHOOTABLE) { return target; }
            else                   { return null;   }
          case 2:
            if (target.bSHOOTABLE || target is "Inventory") { return target; }
            else                                            { return null;   }
          case 3:
            return target;
          }
      }

    return target;
  }

  static string SeparateCamelCase(string source)
  {
    int sourceLength = source.Length();
    string result = "";
    string letter1 = source.CharAt(0);
    string letter2;

    for (int i = 1; i < sourceLength; ++i)
      {
        letter2 = source.CharAt(i);
        if (IsSmallLetter(letter1) && IsBigLetter(letter2))
          {
            result.AppendFormat("%s ", letter1);
          }
        else
          {
            result.AppendFormat(letter1);
          }
        letter1 = letter2;
      }
    result.AppendFormat(letter2);

    return result;
  }

  static bool IsSmallLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (97 <= code && code <= 122);
  }

  static bool IsBigLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (65 <= code && code <= 90);
  }

  static void GetAdditionalTargetInfo(Actor a)
  {
    if (!a) { return; }
    PlayerInfo player =  a.player;
    if (!player) { return; }

    Actor target = GetTarget(a);
    if (target == null) { SendResultString(player, ""); return; }

    string result = "";

    if (target.bFRIENDLY)
      {
        result = "Friendly";
      }

    if (target.bINVULNERABLE)
      {
        if (result.Length() > 0) { result.AppendFormat(" "); }
        result.AppendFormat("Invulnerable");
      }

    if (target.bBOSS)
      {
        if (result.Length() > 0) { result.AppendFormat(" "); }
        result.AppendFormat("Boss");
      }

    SendResultString(player, result);
  }

  static void CustomTargetColor(Actor a)
  {
    if (!a) { return; }
    PlayerInfo player =  a.player;
    if (!player) { return; }

    Actor target = GetTarget(a);
    if (target == null) { SendResultInt(player, 0); return; }

    string customColorTokenClass = "tr_color_token";
    int customColor = target.CountInv(customColorTokenClass);
    SendResultInt(player, customColor);
  }

}

class TagCache : Thinker
{
  string cachedClass;
  string cachedTag;

  void SetCache(string targetClass, string targetTag)
  {
    cachedClass = targetClass;
    cachedTag   = targetTag;
  }

  TagCache Init()
  {
    ChangeStatNum(STAT_INFO);
    return self;
  }

  static TagCache Get()
  {
    let it = ThinkerIterator.Create("TagCache", STAT_INFO);
    let p  = TagCache(it.Next());
    if (p == null) { p = new("TagCache").Init(); }
    return p;
  }
}

class m8f_ts_TargetCache : Thinker
{
  Actor lastTarget;

  m8f_ts_TargetCache Init()
  {
    ChangeStatNum(STAT_INFO);
    lastTarget = null;
    return self;
  }

  static m8f_ts_TargetCache Get()
  {
    let it = ThinkerIterator.Create("m8f_ts_TargetCache", STAT_INFO);
    let p  = m8f_ts_TargetCache(it.Next());
    if (p == null) { p = new("m8f_ts_TargetCache").Init(); }
    return p;
  }
}

class m8f_ts_EventHandler : EventHandler
{
  override void WorldThingDied(WorldEvent event)
  {
    PlayerInfo player = players[consolePlayer];
    if (CVar.GetCVar("m8f_ts_show_confirm", player).GetInt()
        && event.thing == m8f_ts_TargetCache.Get().lastTarget)
    {
      CVar.GetCVar("m8f_ts_KillConfirmed", player).SetInt(10);
    }
  }
}

class m8f_ts_InvisiblePuff : Actor
{
  Default
  {
    Mass 0;
    Radius 1;
    Height 2;
    +NOBLOCKMAP;
    +NOGRAVITY;
    +BLOODLESSIMPACT;
    +PUFFONACTORS;
    +DONTSPLASH;
    +NOTRIGGER;
    +FORCEXYBILLBOARD;
    +NOTONAUTOMAP;
  }

  States { Spawn: TNT1 A 0; Stop; }
}
