version "3.2.0"

/* Copyright Alexander Kromm (mmaulwurff@gmail.com) 2018
 *
 * This file is part of Target Spy.
 *
 * Target Spy is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Target Spy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Target Spy.  If not, see <https://www.gnu.org/licenses/>.
 */

class m8f_ts_TagCache
{
  string cachedClass;
  string cachedTag;

  void SetCache(string targetClass, string targetTag)
  {
    cachedClass = targetClass;
    cachedTag   = targetTag;
  }

  m8f_ts_TagCache Init()
  {
    cachedClass = "";
    cachedTag   = "";
    return self;
  }
}

class m8f_ts_EventHandler : EventHandler
{
  m8f_ts_Settings settings;
  m8f_ts_Data     data;
  bool            isTitlemap;
  int             dehackedGameType;
  Actor           lastTarget;
  int             lastTargetKillTime;

  override void WorldLoaded(WorldEvent e)
  {
    settings           = new("m8f_ts_Settings").init(players[consolePlayer]);
    data               = new("m8f_ts_Data").init();
    isTitlemap         = CheckTitlemap();
    dehackedGameType   = GetDehackedGameType();
    lastTarget         = null;
    lastTargetKillTime = -1;
  }

  override void WorldThingDied(WorldEvent event)
  {
    if (event == null) { return; }

    Actor died = event.thing;
    if (died == null) { return; }

    if (lastTarget == died)
    {
      lastTargetKillTime = level.time;
    }
  }

  override void RenderOverlay(RenderEvent e)
  {
    if (isTitlemap) { return; }

    PlayerInfo player = players[consolePlayer];

    if (settings.optionsUpdatePeriod == 0) { settings.read(player); }
    else if (settings.optionsUpdatePeriod != -1
             && Level.time % settings.optionsUpdatePeriod)
      {
        settings.read(player);
      }

    drawEverything(player);
  }

  ui void drawEverything(PlayerInfo player)
  {
    if (!CVar.GetCVar("m8f_ts_enabled", player).GetInt()) { return; }

    Actor playerActor = player.mo;
    if (playerActor == null) { return; }

    Actor target = GetTarget(playerActor);

    drawCrosshairs(target);
    drawLines(target, player);

    SetLastTarget(target);
  }

  // Wrapper to access lastTarget in scope play from ui scope.
  // not really const, but lastTarget doesn't affect gameplay.
  void SetLastTarget(Actor newLastTarget) const
  {
    lastTarget = newLastTarget;
  }

  ui void drawCrosshairs(Actor target)
  {
    if (!settings.crossOn) { return; }

    //int   targetMaxHealth = GetActorMaxHealth(target);

    double scale = 0.5;
    int    color = settings.crossCol;

    drawTextCenter(settings.crossTop,  color, scale, 0.54);
    drawTextCenter(settings.crosshair, color, scale, 0.51);
    drawTextCenter(settings.crossBot,  color, scale, 0.48);
  }

  ui void drawLines(Actor target, PlayerInfo player)
  {
    double y       = settings.yStart;
    double newline = 0.03 * settings.stepMult;
    if (y >= 0.95) { newline = -newline; }

    y = drawKillConfirmed(y, newline);

    bool hasTarget = (target != null);
    CVar.GetCVar("m8f_ts_has_target", player).SetInt(hasTarget);

    if (!hasTarget) { return; }

    int  targetMaxHealth = GetActorMaxHealth(target);
    bool showHealth      = (targetMaxHealth != 0);
    if (targetMaxHealth < settings.minHealth && targetMaxHealth != 0)
      {
        return; // not worth showing
      }

    int targetHealth = target.health;
    if (targetHealth < 1 && !settings.showCorps) // target is dead
      {
        return;
      }

    int tagColor;
    if (targetMaxHealth < 100) { tagColor = settings.weakCol; }
    else                       { tagColor = settings.nameCol; }
    int customColor = CustomTargetColor(target);
    if (customColor)           { tagColor = customColor; }

    int percent = 10;
    if (showHealth)
      {
        if (targetHealth > targetMaxHealth) { percent = 11; }
        else { percent = targetHealth * 10 / targetMaxHealth; }
      }

    int targetColor = settings.colors[percent];
    if (targetHealth < 35 && settings.almDeadCr) targetColor = settings.crAlmDead;
    if (targetHealth < 1)                        targetColor = settings.crAlmDead;

    if (settings.showBar && showHealth)
      {
        string hpBar = MakeHpBar(targetHealth, targetMaxHealth,
                                 settings.logScale,
                                 settings.pipSource, settings.emptyPipSource,
                                 settings.altHpCols,
                                 settings.greenCr, settings.redCr);
        drawTextCenter(hpBar, targetColor, 0.5, y);
        y += newline;
      }

    int nameColor = tagColor;
    if (targetHealth < 1) { nameColor = targetColor; }

    if (settings.showName)
      {
        string targetName = GetTargetName(target, dehackedGameType, player);
        if (targetHealth < 1)
          {
            targetName = StringStruct.Format("Remains of %s", targetName);
            nameColor  = targetColor;
          }

        drawTextCenter(targetName, nameColor, 0.5, y);
        y += newline;
      }

    if (settings.showInfo)
      {
        string targetFlags = GetTargetFlags(target);
        if (targetFlags.Length() > 0)
          {
            drawTextCenter(targetFlags, nameColor, 0.5, y);
            y += newline;
          }
      }

    if (showHealth)
      {
        switch (settings.showNums)
          {
          case 0: break;

          case 1:
            drawTextCenter(StringStruct.Format("%d/%d",
                                               targetHealth, targetMaxHealth),
                           targetColor, 0.5, y);
            y += newline;
            break;

          case 2:
            drawTextCenter(StringStruct.Format("%d", targetHealth),
                           targetColor, 0.5, y);
            y += newline;
            break;

          case 3:
            int percent100;
            if (targetMaxHealth == 0) { percent100 = 100; }
            else { percent100 = targetHealth * 100 / targetMaxHealth; }

            drawTextCenter(StringStruct.Format("%d%", percent100),
                           targetColor, 0.5, y);
            y += newline;
            break;
          }
      }
  }

  ui double drawKillConfirmed(double y, double newline)
  {
    if (!settings.showKillConfirmation) { return y; }
    if (lastTargetKillTime == -1) { return y; }
    if (level.time < lastTargetKillTime + 35 * 2)
      {
        drawTextCenter("Kill Confirmed", settings.nameCol, 0.5, y);
        y += newline;
      }
    return y;
  }

  ui void drawTextCenter(string text, int color, double scale, double relativeY)
  {
    int width    = scale * Screen.GetWidth();
    int height   = scale * (Screen.GetHeight() - settings.font.GetHeight());
    int position = width - settings.font.StringWidth(text);

    // fix one-pixel offset
    if (position % 2) { --position; }

    double x = position * 0.5;
    double y = height   * relativeY;

    Screen.DrawText(settings.font, color, x, y, text,
                    DTA_KeepRatio,     true,
                    DTA_VirtualWidth,  width,
                    DTA_VirtualHeight, height);
  }

  ui Actor GetTarget(Actor a, int gameType = 0)
  {
    let player = a.player;
    if (!player) { return null; }

    // try an easy way to get a target (also works with autoaim)
    m8f_ts_PlayToUiTranslator translator = new("m8f_ts_PlayToUiTranslator");
    Actor target = translator.AimTargetWrapper(player.mo);

    // if target is not found by easy way, try the difficult way
    if (target == null)
      {
        target = translator.LineAttackTargetWrapper(a);
      }

    int showObjects = CVar.GetCVar("m8f_ts_show_objects", player).GetInt();

    if (target == null && showObjects > 1)
      {
        target = translator.AimLineAttackWrapper(a);
      }

    // give up
    if (target == null) { return null; }

    string targetClass   = target.GetClassName();
    bool   targetIsSlave = data.slaveActors.contains(targetClass);
    if (targetIsSlave) { return target.Master; }

    bool isInBlackList = data.blackList.contains(targetClass);
    if (isInBlackList) { return null; }

    switch (gameType)
      {
      case 1: targetClass.AppendFormat("_free" ); break; // Freedoom
      case 2: targetClass.AppendFormat("_rekkr"); break; // Rekkr
      }

    // everything without name in REKKR is "blacklisted"
    if (targetClass.IndexOf("_rekkr") != -1)
      {
        string specialName = data.specialNames.get(targetClass);
        if (specialName.length() == 0) { return null; }
      }

    if (target.bISMONSTER)
      {
        if (target.bSHADOW || target.bSTEALTH)
          {
            bool showHidden = CVar.GetCVar("m8f_ts_show_hidden", player).GetInt();
            if (!showHidden) { return null; }
          }
        if (target.bFRIENDLY)
          {
            bool showFriends = CVar.GetCVar("m8f_ts_show_friends", player).GetInt();
            if (!showFriends) { return null; }
          }
      }
    else // not monsters
      {
        switch (showObjects)
          {
          case 0: return null;
          case 1:
            if (target.bSHOOTABLE) { return target; }
            else                   { return null;   }
          case 2:
            if (target.bSHOOTABLE || target is "Inventory") { return target; }
            else                                            { return null;   }
          case 3:
            return target;
          }
      }

    return target;
  }

  ui int GetActorMaxHealth(Actor a)
  {
    if (a == null)     { return 0; }
    if (!a.bSHOOTABLE) { return 0; }

    int maxHealth = a.SpawnHealth();
    return maxHealth;
  }

  ui int CustomTargetColor(Actor target)
  {
    string customColorTokenClass = "tr_color_token";
    int customColor = target.CountInv(customColorTokenClass);
    return customColor;
  }

  ui static int Log2(int value)
  {
    int result = -1;
    while (value)
      {
        ++result;
        value /= 2;
      }
    return result;
  }

  ui string MakeHpBar(int health, int maxHealth, bool logScale,
                      string pipSource, string emptyPipSource,
                      bool greenRedTheme, int greenColor, int redColor)
  {
    int length;
    if      (logScale)          { length = Log2(maxHealth) * 2; }
    else if (maxHealth >= 2000) { length = 30; }
    else if (maxHealth >= 500)  { length = 20; }
    else                        { length = 10; }

    int pips = health * length / maxHealth;
    if      (pips == 0)      { pips = 1; }
    else if (pips >  length) { pips = length; }

    string pipColor;
    string emptyColor;
    if (greenRedTheme)
      {
        pipColor   = StringStruct.Format("\c%c", 97 + greenColor); // 'a'
        emptyColor = StringStruct.Format("\c%c", 97 + redColor);   // 'a'
      }
    else
      {
        pipColor   = "";
        emptyColor = "";
      }

    return StringStruct.Format("%s%s%s%s",
                               pipColor,   pipSource.Left(pips),
                               emptyColor, emptyPipSource.Left(length - pips));

  }

  bool CheckTitlemap()
  {
    bool isTitlemap = (level.mapname == "TITLEMAP");
    return isTitlemap;
  }

  int GetDehackedGameType()
  {
    string checkString = StringTable.Localize("$E1TEXT");
    string rekkrString = "You've been through war.";
    bool   isRekkr     = (checkString.IndexOf(rekkrString) >= 0);
    if (isRekkr) { return 2; }

    string impName     = StringTable.Localize("$CC_IMP");
    bool   isFreedoom  = (impName == "serpentipede");
    if (isFreedoom) { return 1; }

    return 0;
  }

  ui string GetTargetName(Actor target, int gameType, PlayerInfo player)
  {
    string targetClass = target.GetClassName();

    bool showInternalNames = CVar.GetCVar("m8f_class_as_tag", player).GetInt();
    if (showInternalNames) { return targetClass; }

    switch (gameType)
      {
      case 1: targetClass.AppendFormat("_free" ); break; // Freedoom
      case 2: targetClass.AppendFormat("_rekkr"); break; // Rekkr
      }

    // if target name was found before, just return it
    // TODO: restore tag cache
    //let cache = TagCache.Get();
    //if (cache.cachedClass == targetClass)
    //  {
    //    SendResultString(player, AddAdditionalInfo(a, target, cache.cachedTag));
    //    return;
    //  }

    // if target name is set via actor tag, return it
    string targetName = target.GetTag();
    if (targetName != targetClass && !(gameType != 0))
      {
        //cache.SetCache(targetClass, targetName);
        return AddAdditionalInfo(target, targetName);
      }

    string specialName = data.specialNames.get(targetClass);
    if (specialName.Length() != 0)
      {
        targetName = specialName;
        //cache.SetCache(targetClass, targetName);
        return AddAdditionalInfo(target, targetName);
      }

    // if target name is not found, compose tag from class name
    targetName = SeparateCamelCase(targetName);
    targetName.Replace("_", " ");

    //cache.SetCache(targetClass, targetName);
    return AddAdditionalInfo(target, targetName);
  }

  ui string AddAdditionalInfo(Actor target, string name)
  {
    Inventory inv = Inventory(target);
    if (inv)
      {
        int amount = inv.amount;
        if (amount == 1)
          {
            BasicArmorPickup armor = BasicArmorPickup(inv);
            if (armor) { amount = armor.SaveAmount; }
          }
        if (amount == 1) { return name; }
        else             { return StringStruct.Format("%s (%i)", name, amount); }
      }
    else
      {
        return PrependChampionColor(target, name);
      }
  }

  ui string PrependChampionColor(Actor target, string name)
  {
    if (!settings.showChampion) { return name; }

    string tokenClass = "champion_Token";
    Inventory token = target.FindInventory(tokenClass, true);
    if (!token) { return name; }

    string tokenClassName = token.GetClassName();
    string championTag    = data.championTokens.get(tokenClassName);
    if (championTag.Length() == 0) { championTag = "Champion"; }

    championTag.AppendFormat(" %s", name);
    return championTag;
  }

  ui static string SeparateCamelCase(string source)
  {
    int sourceLength = source.Length();
    string result = "";
    string letter1 = source.CharAt(0);
    string letter2;

    for (int i = 1; i < sourceLength; ++i)
      {
        letter2 = source.CharAt(i);
        if (IsSmallLetter(letter1) && IsBigLetter(letter2))
          {
            result.AppendFormat("%s ", letter1);
          }
        else
          {
            result.AppendFormat(letter1);
          }
        letter1 = letter2;
      }
    result.AppendFormat(letter2);

    return result;
  }

  ui static bool IsSmallLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (97 <= code && code <= 122);
  }

  ui static bool IsBigLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (65 <= code && code <= 90);
  }

  ui string GetTargetFlags(Actor target)
  {
    string result = "";

    if (target.bFRIENDLY)
      {
        result = "Friendly";
      }

    if (target.bINVULNERABLE)
      {
        if (result.Length() > 0) { result.AppendFormat(" "); }
        result.AppendFormat("Invulnerable");
      }

    if (target.bBOSS)
      {
        if (result.Length() > 0) { result.AppendFormat(" "); }
        result.AppendFormat("Boss");
      }

    return result;
  }

} // class m8f_ts_EventHandler

class m8f_ts_InvisiblePuff : Actor
{
  Default
  {
    Mass 0;
    Radius 1;
    Height 2;
    +NOBLOCKMAP;
    +NOGRAVITY;
    +BLOODLESSIMPACT;
    +PUFFONACTORS;
    +DONTSPLASH;
    +NOTRIGGER;
    +FORCEXYBILLBOARD;
    +NOTONAUTOMAP;
  }

  States { Spawn: TNT1 A 0; Stop; }
}

class m8f_ts_StringSet
{
  Array<string> values;

  void print()
  {
    uint size = values.size();
    Console.Printf("Size: %d", size);
    for (int i = 0; i < size; ++i)
      {
        Console.Printf(values[i]);
      }
  }

  void push(string s)
  {
    // array is sorted
    uint size = values.size();
    uint i    = 0;
    for (; i < size && values[i] < s; ++i);
    values.insert(i, s);
  }

  bool contains(string s)
  {
    // binary search
    int size = values.size();
    int L    = 0;
    int R    = size - 1;

    while (L <= R)
      {
        int m = (L + R) / 2;
        string current = values[m];
        if      (current <  s) { L = m + 1; }
        else if (current >  s) { R = m - 1; }
        else if (current == s) { return true; }
      }
    return false;
  }
}

class m8f_ts_StringMap
{
  Array<string> keys;
  Array<string> values;

  void print()
  {
    uint size = values.size();
    Console.Printf("Size: %d", size);
    for (int i = 0; i < size; ++i)
      {
        Console.Printf("%s: %s", keys[i], values[i]);
      }
  }

  void push(string key, string value)
  {
    // array is sorted
    uint size = values.size();
    uint i    = 0;
    for (; i < size && keys[i] < key; ++i);
    keys.insert(i, key);
    values.insert(i, value);
  }

  string get(string key)
  {
    // binary search
    int size = values.size();
    int L    = 0;
    int R    = size - 1;

    while (L <= R)
      {
        int m = (L + R) / 2;
        string current = keys[m];
        if      (current <  key) { L = m + 1; }
        else if (current >  key) { R = m - 1; }
        else if (current == key) { return values[m]; }
      }
    return "";
  }
}

class m8f_ts_StringSetTester : Actor
{
  States { Spawn: TNT1 A 0; TNT1 A 0
    {

      let set = new("m8f_ts_StringSet");
      set.push("3three");
      set.push("2two");
      set.push("1one");
      set.push("4");
      set.push("2two");
      set.print();

      Console.Printf("%d", set.contains("4"));
      Console.Printf("%d", set.contains("5"));
      Console.Printf("%d", set.contains("2two"));

    } stop; }
}

class m8f_ts_StringMapTester : Actor
{
  States { Spawn: TNT1 A 0; TNT1 A 0
    {

      let set = new("m8f_ts_StringMap");
      set.push("3", "three");
      set.push("2", "two");
      set.push("1", "one");
      set.push("4", "four");
      set.push("2", "two");
      set.print();

      Console.Printf("%s", set.get("4"));
      Console.Printf("%s", set.get("5"));
      Console.Printf("%s", set.get("2two"));
      Console.Printf("%s", set.get("2"));

    } stop; }
}

class m8f_ts_Data
{
  m8f_ts_StringMap championTokens;
  m8f_ts_StringMap specialNames;
  m8f_ts_StringSet slaveActors;
  m8f_ts_StringSet blackList;

  m8f_ts_Data init()
  {
    championTokens = new("m8f_ts_StringMap");
    specialNames   = new("m8f_ts_StringMap");
    slaveActors    = new("m8f_ts_StringSet");
    blackList      = new("m8f_ts_StringSet");

    championTokens.push( "champion_BlackToken"     , "Brutal"      );
    championTokens.push( "champion_BlueToken"      , "Retaliating" );
    championTokens.push( "champion_BronzeToken"    , "Tough"       );
    championTokens.push( "champion_CyanToken"      , "Vortex"      );
    championTokens.push( "champion_DarkGreenToken" , "Toxic"       );
    championTokens.push( "champion_DarkRedToken"   , "Reanimating" );
    championTokens.push( "champion_GoldToken"      , "Golden"      );
    championTokens.push( "champion_GreenToken"     , "Phasing"     );
    championTokens.push( "champion_GreyToken"      , "Nimble"      );
    championTokens.push( "champion_IndigoToken"    , "Fissile"     );
    championTokens.push( "champion_OrangeToken"    , "Exploding"   );
    championTokens.push( "champion_PinkToken"      , "Healer"      );
    championTokens.push( "champion_RedToken"       , "Sturdy"      );
    championTokens.push( "champion_SilverToken"    , "Reflective"  );
    championTokens.push( "champion_VioletToken"    , "Relentless"  );
    championTokens.push( "champion_WhiteToken"     , "Restraining" );
    championTokens.push( "champion_YellowToken"    , "Fast"        );

    specialNames.push( "Arachnotron_free"        , "Technospider"       );
    specialNames.push( "Archvile"                , "Arch-vile"          );
    specialNames.push( "Archvile_free"           , "Flame Bringer"      );
    specialNames.push( "BD_Arachnotron"          , "Arachnotron"        );
    specialNames.push( "BD_ArchVile"             , "Arch-vile"          );
    specialNames.push( "BD_BaronOfHell"          , "Baron Of Hell"      );
    specialNames.push( "BD_Cacodemon"            , "Cacodemon"          );
    specialNames.push( "BD_ChaingunGuy"          , "Chaingunner"        );
    specialNames.push( "BD_CyberDemon"           , "Cyberdemon"         );
    specialNames.push( "BD_Demon"                , "Demon"              );
    specialNames.push( "BD_DoomImp"              , "Imp"                );
    specialNames.push( "BD_Fatso"                , "Mancubus"           );
    specialNames.push( "BD_HellKnight"           , "Hell Knight"        );
    specialNames.push( "BD_LostSoul"             , "Lost Soul"          );
    specialNames.push( "BD_PainElemental"        , "Pain Elemental"     );
    specialNames.push( "BD_Revenant"             , "Revenant"           );
    specialNames.push( "BD_ShotgunGuy"           , "Sergeant"           );
    specialNames.push( "BD_Spectre"              , "Spectre"            );
    specialNames.push( "BD_SpiderMastermind"     , "Spider Mastermind"  );
    specialNames.push( "BD_WolfensteinSS"        , "Wolfenstein SS"     );
    specialNames.push( "BaronOfHell_free"        , "Pain Lord"          );
    specialNames.push( "Cacodemon_free"          , "Trilobite"          );
    specialNames.push( "ChaingunGuy"             , "Chaingunner"        );
    specialNames.push( "ChaingunGuy_free"        , "Minigun Zombie"     );
    specialNames.push( "CommanderKeen_free"      , "Alien Spawn"        );
    specialNames.push( "Cyberdemon_free"         , "Assault Tripod"     );
    specialNames.push( "Demon_free"              , "Flesh Worm"         );
    specialNames.push( "DoomImp"                 , "Imp"                );
    specialNames.push( "DoomImp_free"            , "Serpentipede"       );
    specialNames.push( "EVPArachnotron"          , "Arachnotron"        );
    specialNames.push( "EVPArchVile"             , "Arch-vile"          );
    specialNames.push( "EVPBaron"                , "Baron Of Hell"      );
    specialNames.push( "EVPCacodemon"            , "Cacodemon"          );
    specialNames.push( "EVPChaingunner"          , "Chaingunner"        );
    specialNames.push( "EVPCyberdemon"           , "Cyberdemon"         );
    specialNames.push( "EVPDemon"                , "Demon"              );
    specialNames.push( "EVPHellKnight"           , "Hell Knight"        );
    specialNames.push( "EVPImp"                  , "Imp"                );
    specialNames.push( "EVPLostSoul"             , "Lost Soul"          );
    specialNames.push( "EVPMancubus"             , "Mancubus"           );
    specialNames.push( "EVPPainElemental"        , "Pain Elemental"     );
    specialNames.push( "EVPRevenant"             , "Revenant"           );
    specialNames.push( "EVPShotgunner"           , "Sergeant"           );
    specialNames.push( "EVPSpectre"              , "Spectre"            );
    specialNames.push( "EVPSpiderMastermind"     , "Spider Mastermind"  );
    specialNames.push( "Fatso"                   , "Mancubus"           );
    specialNames.push( "Fatso_free"              , "Combat Slug"        );
    specialNames.push( "LostSoul_free"           , "Deadflare"          );
    specialNames.push( "PainElemental_free"      , "Summoner"           );
    specialNames.push( "Revenant_free"           , "Dark Soldier"       );
    specialNames.push( "ShotgunGuy"              , "Sergeant"           );
    specialNames.push( "ShotgunGuy_free"         , "Shotgun Zombie"          );
    specialNames.push( "SpiderMastermind_free"   , "Large Technospider"      );
    specialNames.push( "WolfensteinSS_free"      , "Sailor"                  );
    specialNames.push( "ZombieMan_free"          , "Zombie"                  );
    specialNames.push( "Cacodemon_rekkr"         , "Sorrow"                  );
    specialNames.push( "Demon_rekkr"             , "Husk"                    );
    specialNames.push( "Spectre_rekkr"           , "Mean Husk"               );
    specialNames.push( "BaronOfHell_rekkr"       , "Treebeast"               );
    specialNames.push( "HellKnight_rekkr"        , "Skelly Belly"            );
    specialNames.push( "Zombieman_rekkr"         , "Former Human"            );
    specialNames.push( "ShotgunGuy_rekkr"        , "Jackalope"               );
    specialNames.push( "Archvile_rekkr"          , "Turret"                  );
    specialNames.push( "Revenant_rekkr"          , "Mean Imp"                );
    specialNames.push( "Fatso_rekkr"             , "Former Duke"             );
    specialNames.push( "ChaingunGuy_rekkr"       , "Former King"             );
    specialNames.push( "Chaingun_rekkr"          , "Former King"             );
    specialNames.push( "LostSoul_rekkr"          , "Eyeball"                 );
    specialNames.push( "SpiderMastermind_rekkr"  , "Dark Foe"                );
    specialNames.push( "Cyberdemon_rekkr"        , "Dark Foe"                );
    specialNames.push( "Arachnotron_rekkr"       , "Mean Jackalope"          );
    specialNames.push( "WolfensteinSS_rekkr"     , "Grotesque"               );
    specialNames.push( "DoomImp_rekkr"           , "Imp"                     );
    specialNames.push( "HangNoGuts_rekkr"        , "Spider"                  );
    specialNames.push( "DehackedPickup4_rekkr"   , "Soul Launcher"           );
    specialNames.push( "DeadShotgunGuy_rekkr"    , "Remains of Grotesque"    );
    specialNames.push( "DeadZombieMan_rekkr"     , "Remains of Former Human" );
    specialNames.push( "DeadDemon_rekkr"         , "Remains of Husk"         );
    specialNames.push( "DeadCacodemon_rekkr"     , "Remains of Sorrow"       );
    specialNames.push( "GibbedMarineExtra_rekkr" , "Remains of Viking"       );
    specialNames.push( "GibbedMarine_rekkr"      , "Remains of Viking"       );
    specialNames.push( "HeadsOnAStick_rekkr"     , "Tree"                    );
    specialNames.push( "CommanderKeen_rekkr"     , "Bottled Health"          );
    specialNames.push( "DehackedPickup14_rekkr"  , "Platemail Armor"         );
    specialNames.push( "DehackedPickup13_rekkr"  , "Ringmail Armor"          );
    specialNames.push( "DehackedPickup16_rekkr"  , "Health Essence"          );
    specialNames.push( "Medikit_rekkr"           , "Bottled Health"          );
    specialNames.push( "DehackedPickup15_rekkr"  , "Medicinal Herb"          );
    specialNames.push( "ArmorBonus_rekkr"        , "Armor Patch"             );
    specialNames.push( "Backpack_rekkr"          , "Sack of Carrying"        );
    specialNames.push( "DehackedPickup12_rekkr"  , "Mana Seal"               );
    specialNames.push( "DehackedPickup0_rekkr"   , "Mana Sprite"             );
    specialNames.push( "RocketBox_rekkr"         , "Stack of Runes"          );
    specialNames.push( "RocketAmmo_rekkr"        , "Rune"                    );
    specialNames.push( "ShellBox_rekkr"          , "Sack of Steelshot"       );
    specialNames.push( "Shell_rekkr"             , "Steelshot"               );
    specialNames.push( "ClipBox_rekkr"           , "Soul Prism"              );
    specialNames.push( "Berserk_rekkr"           , "WODE"                    );
    specialNames.push( "Allmap_rekkr"            , "Map of the Area"         );
    specialNames.push( "RadSuit_rekkr"           , "Boots of Protection"     );
    specialNames.push( "DehackedPickup17_rekkr"  , "Shamans Brew"            );
    specialNames.push( "DehackedPickup18_rekkr"  , "Ethereal Guard"          );
    specialNames.push( "DehackedPickup19_rekkr"  , "Cloak of deceit"         );
    specialNames.push( "DehackedPickup20_rekkr"  , "Torch"                   );
    specialNames.push( "DehackedPickup21_rekkr"  , "Soul"                    );
    specialNames.push( "DeadMarine_rekkr"        , "Dead Body"               );
    specialNames.push( "DeadLostSoul_rekkr"      , "Remains of Eyeball"      );
    specialNames.push( "LiveStick_rekkr"         , "Puppy"                   );
    specialNames.push( "HeadOnAStick_rekkr"      , "Grass"                   );
    specialNames.push( "Gibs_rekkr"              , "Blood"                   );
    specialNames.push( "DehackedPickup5_rekkr"   , "Soul"                    );
    specialNames.push( "DeadStick_rekkr"         , "Dead Body"               );
    specialNames.push( "RedCard_rekkr"           , "Red Key"                 );
    specialNames.push( "BlueCard_rekkr"          , "Blue Key"                );
    specialNames.push( "YellowCard_rekkr"        , "Yellow Key"              );
    specialNames.push( "ExplosiveBarrel_rekkr"   , "Barrel"                  );
    specialNames.push( "RedSkull_rekkr"          , "Red Skeleton Key"        );
    specialNames.push( "BlueSkull_rekkr"         , "Blue Skeleton Key"       );
    specialNames.push( "YellowSkull_rekkr"       , "Yellow Skeleton Key"     );
    specialNames.push( "DehackedPickup11_rekkr"  , "Blessing of the Gods"    );
    specialNames.push( "DehackedPickup10_rekkr"  , "Holy Relic"              );
    specialNames.push( "DehackedPickup8_rekkr"   , "Runic Staff"             );
    specialNames.push( "DehackedPickup9_rekkr"   , "Axe"                     );


    slaveActors.push( "HeadshotTargetZombie"        );
    slaveActors.push( "HeadshotTargetEliteZombie"   );
    slaveActors.push( "HeadshotTargetImp"           );
    slaveActors.push( "HeadshotTargetAngryImp"      );
    slaveActors.push( "HeadshotTargetNoble"         );
    slaveActors.push( "HeadshotTargetEliteNoble"    );
    slaveActors.push( "HeadshotTargetBossNoble"     );
    slaveActors.push( "HeadshotTargetArchvile"      );
    slaveActors.push( "HeadshotTargetEliteArchvile" );
    slaveActors.push( "HeadshotTargetRevenant"      );
    slaveActors.push( "HeadshotTargetEliteRevenant" );
    slaveActors.push( "HeadshotTargetMancubus"      );
    slaveActors.push( "HeadshotTargetSoulCommander" );
    slaveActors.push( "HeadshotTargetCacodemon"     );
    slaveActors.push( "HeadshotTargetPainElemental" );
    slaveActors.push( "HeadshotTargetDemon"         );
    slaveActors.push( "HeadshotTargetCyberdemon"    );

    blackList.push( "m8f_aas_token"           );
    blackList.push( "AutoautosaveToken"       );
    blackList.push( "AutoautosaveAlertToken"  );
    blackList.push( "AutoautosaveAlerter"     );
    blackList.push( "AutoautosaveBossAlerter" );
    blackList.push( "UGGib_Corpse_Shootable"  );
    blackList.push( "VoidField"               );
    blackList.push( "Cow"                     );
    blackList.push( "WinterCow"               );
    blackList.push( "SpaceCow"                );
    blackList.push( "SpaceCowFloating"        );
    blackList.push( "CowboyCow"               );
    blackList.push( "MummyCow"                );

    return self;
  }
}

class m8f_ts_Settings
{
  int colors[12];

  bool showKillConfirmation;
  bool isEnabled;

  int    minHealth;
  double yStart;
  bool logScale;
  bool showBar;
  bool showName;
  int  showNums;
  bool showInfo;
  bool showCorps;
  bool crossOn;
  int  crossCol;
  int  nameCol;
  int  weakCol;
  bool altHpCols;
  int  stepMult;
  bool almDeadCr;
  int  crAlmDead;
  int  crossOff;
  int  topOff;
  int  botOff;
  int  greenCr;
  int  redCr;
  bool showChampion;

  string pip;
  string emptyPip;
  string fontName;
  string crosshair;
  string crossTop;
  string crossBot;

  int optionsUpdatePeriod;

  string pipSource;
  string emptyPipSource;

  Font font;

  void read(PlayerInfo player)
  {
    showKillConfirmation = CVar.GetCVar("m8f_ts_show_confirm" , player).GetInt();
    isEnabled            = CVar.GetCVar("m8f_ts_enabled"      , player).GetInt();
    minHealth            = CVar.GetCVar("m8f_ts_min_health"   , player).GetInt();
    yStart               = CVar.GetCVar("m8f_ts_y"            , player).GetFloat();
    logScale             = CVar.GetCVar("m8f_ts_bar_log_scale", player).GetInt();
    showBar              = CVar.GetCVar("m8f_ts_show_bar"     , player).GetInt();
    showName             = CVar.GetCVar("m8f_ts_show_name"    , player).GetInt();
    showNums             = CVar.GetCVar("m8f_ts_show_numbers" , player).GetInt();
    showInfo             = CVar.GetCVar("m8f_ts_show_info"    , player).GetInt();
    showCorps            = CVar.GetCVar("m8f_ts_show_corpses" , player).GetInt();
    crossOn              = CVar.GetCVar("m8f_ts_crosshair_on" , player).GetInt();
    crossCol             = CVar.GetCVar("m8f_ts_def_color_crs", player).GetInt();
    nameCol              = CVar.GetCVar("m8f_ts_def_color_tag", player).GetInt();
    weakCol              = CVar.GetCVar("m8f_ts_def_cl_tag_wk", player).GetInt();
    altHpCols            = CVar.GetCVar("m8f_ts_alt_hp_color" , player).GetInt();
    crAlmDead            = CVar.GetCVar("m8f_ts_cr_alm_dead"  , player).GetInt();
    stepMult             = CVar.GetCVar("m8f_ts_step_mult"    , player).GetInt();
    almDeadCr            = CVar.GetCVar("m8f_ts_alm_dead_cr"  , player).GetInt();
    crossOff             = CVar.GetCVar("m8f_ts_cross_offset" , player).GetInt();
    topOff               = CVar.GetCVar("m8f_ts_top_offset"   , player).GetInt();
    botOff               = CVar.GetCVar("m8f_ts_bot_offset"   , player).GetInt();
    greenCr              = CVar.GetCVar("m8f_ts_green_color"  , player).GetInt();
    redCr                = CVar.GetCVar("m8f_ts_red_color"    , player).GetInt();
    optionsUpdatePeriod  = CVar.GetCVar("m8f_ts_update_period", player).GetInt();
    showChampion         = CVar.GetCVar("m8f_ts_show_champion", player).GetInt();

    pip       = CVar.GetCVar("m8f_ts_pip"          , player).GetString();
    emptyPip  = CVar.GetCVar("m8f_ts_empty_pip"    , player).GetString();
    fontName  = CVar.GetCVar("m8f_ts_font"         , player).GetString();
    crosshair = CVar.GetCVar("m8f_ts_crosshair"    , player).GetString();
    crossTop  = CVar.GetCVar("m8f_ts_cross_top"    , player).GetString();
    crossBot  = CVar.GetCVar("m8f_ts_cross_bottom" , player).GetString();

    colors[ 0] = CVar.GetCVar("m8f_ts_cr_0" , player).GetInt();
    colors[ 1] = CVar.GetCVar("m8f_ts_cr_1" , player).GetInt();
    colors[ 2] = CVar.GetCVar("m8f_ts_cr_2" , player).GetInt();
    colors[ 3] = CVar.GetCVar("m8f_ts_cr_3" , player).GetInt();
    colors[ 4] = CVar.GetCVar("m8f_ts_cr_4" , player).GetInt();
    colors[ 5] = CVar.GetCVar("m8f_ts_cr_5" , player).GetInt();
    colors[ 6] = CVar.GetCVar("m8f_ts_cr_6" , player).GetInt();
    colors[ 7] = CVar.GetCVar("m8f_ts_cr_7" , player).GetInt();
    colors[ 8] = CVar.GetCVar("m8f_ts_cr_8" , player).GetInt();
    colors[ 9] = CVar.GetCVar("m8f_ts_cr_9" , player).GetInt();
    colors[10] = CVar.GetCVar("m8f_ts_cr_10", player).GetInt();
    colors[11] = CVar.GetCVar("m8f_ts_cr_11", player).GetInt();

    font = Font.GetFont(fontName);

    pipSource      = Repeat(pip,      50);
    emptyPipSource = Repeat(emptyPip, 50);
  }

  m8f_ts_Settings Init(PlayerInfo player)
  {
    read(player);
    return self;
  }

  string Repeat(string s, int times)
  {
    string result = "";
    for (int i = 0; i < times; ++i) { result.AppendFormat("%s", s); }
    return result;
  }
}

class m8f_ts_PlayToUiTranslator
{
  play Actor AimTargetWrapper(Actor a) const
  {
    return a.AimTarget();
  }

  play Actor LineAttackTargetWrapper(Actor a) const
  {
    FTranslatedLineTarget victimTarget;
    a.LineAttack(a.angle, 4000.0, a.pitch, 0, "none",
                 "m8f_ts_InvisiblePuff", LAF_NOIMPACTDECAL, victimTarget);
    return victimTarget.linetarget;
  }

  play Actor AimLineAttackWrapper(Actor a) const
  {
    FTranslatedLineTarget ftlt;
    a.AimLineAttack(a.angle, 2048.0, ftlt, 0,
                    ALF_CHECKNONSHOOTABLE | ALF_FORCENOSMART);
    return ftlt.linetarget;
  }
}
