/* Copyright Alexander Kromm (mmaulwurff@gmail.com) 2018
 *
 * This file is part of Target Spy.
 *
 * Target Spy is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Target Spy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Target Spy.  If not, see <https://www.gnu.org/licenses/>.
 */

class m8f_ts_EventHandler : EventHandler
{

  // Attributes section ////////////////////////////////////////////////////////

  private m8f_ts_MultiSettings       multiSettings;
  private m8f_ts_MultiLastTargetInfo multiLastTargetInfo;

  private m8f_ts_Data     data;
  private bool            isTitlemap;
  private int             dehackedGameType;

  private m8f_ts_TagCache cache;
  private m8f_ts_PlayToUiTranslator translator;

  // EventHandler overrides section ////////////////////////////////////////////

  override void OnRegister()
  {
    multiSettings       = new("m8f_ts_MultiSettings").init();
    multiLastTargetInfo = new("m8f_ts_MultiLastTargetInfo").init();
    translator          = new("m8f_ts_PlayToUiTranslator");
  }

  override void WorldLoaded(WorldEvent e)
  {
    data               = new("m8f_ts_Data").init();
    isTitlemap         = m8f_ts_Game.CheckTitlemap();
    dehackedGameType   = GetDehackedGameType();

    cache              = new("m8f_ts_TagCache").init();
  }

  override void PlayerEntered(PlayerEvent e)
  {
    multiSettings.read(e.playerNumber);
  }

  override void WorldThingDied(WorldEvent event)
  {
    if (event == null) { return; }

    Actor died = event.thing;
    if (died == null) { return; }

    for (int i = 0; i < MAXPLAYERS; ++i)
    {
      let lastTargetInfo = multiLastTargetInfo.get(i);
      if (lastTargetInfo.a == died)
      {
        lastTargetInfo.killTime = level.time;
      }
    }
  }

  override void WorldThingDamaged(WorldEvent event)
  {
    if (event == null) { return; }

    Actor damagedThing = event.thing;
    if (damagedThing == null) { return; }


    for (int i = 0; i < MAXPLAYERS; ++i)
      {
        let lastTargetInfo = multiLastTargetInfo.get(i);
        if (lastTargetInfo.a == damagedThing)
          {
            lastTargetInfo.hurtTime = level.time;
          }
      }
  }

  override void RenderOverlay(RenderEvent event)
  {
    if (isTitlemap) { return; }

    int        playerNumber = event.camera.PlayerNumber();
    PlayerInfo player       = players[playerNumber];
    Actor      playerActor  = player.mo;
    if (!playerActor) { return; }

    multiSettings.maybeUpdate(playerNumber);

    if (automapActive) { return; }

    drawEverything(playerNumber, event);
  }

  // Helper functions section //////////////////////////////////////////////////

  private ui void drawEverything(int playerNumber, RenderEvent event)
  {
    PlayerInfo player = players[playerNumber];
    if (!CVar.GetCVar("m8f_ts_enabled", player).GetInt()) { return; }

    Actor target = GetTarget(playerNumber, 0);

    draw(target, playerNumber, event);

    bool hasTarget = (target != null);
    CVar.GetCVar("m8f_ts_has_target", player).SetInt(hasTarget);
    Cvar.GetCVar("m8f_ts_friendly_target", player).SetInt(hasTarget && target.bFRIENDLY);

    if (hasTarget)
    {
      SetLastTarget(target, playerNumber);
    }
  }

  // https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
  private ui void drawFrame(RenderEvent event, int playerNumber, Actor target, int color)
  {
    PlayerInfo player = players[playerNumber];

    let     worldToClip      = m8f_ts_Matrix.worldToClip( event.viewPos
                                                        , event.viewAngle
                                                        , event.viewPitch
                                                        , event.viewRoll
                                                        , player.FOV
                                                        );
    Vector3 adjustedWorldPos = event.viewPos + LevelLocals.vec3Diff(event.viewPos, target.pos);
    Vector3 ndcPos           = worldToClip.multiplyVector3(adjustedWorldPos + (0, 0, target.height / 2.0))
                                          .asVector3();

    if (-1 < ndcPos.z && ndcPos.z <= 1)
    {
      // this is the coordinates where you're drawing to:
      Vector2 centerPos     = m8f_ts_GlobalMaths.ndcToViewPort(ndcPos);
      double  distance      = player.mo.Distance3D(target);
      double  height        = target.height;
      double  radius        = target.radius;
      double  visibleRadius = radius * 2000.0 / distance;
      double  visibleHeight = height * 1000.0 / distance;

      let  settings         = multiSettings.get(playerNumber);
      let  f                = Font.GetFont(settings.fontName);

      //drawCleanText(centerPos.x, centerPos.y, "+", f);
      Vector2 left   = (centerPos.x - visibleRadius / 2.0, centerPos.y);
      Vector2 right  = (centerPos.x + visibleRadius / 2.0, centerPos.y);
      Vector2 top    = (centerPos.x, centerPos.y - visibleHeight / 2.0);
      Vector2 bottom = (centerPos.x, centerPos.y + visibleHeight / 2.0);

      Vector2 topLeft     = (left.x,  top.y);
      Vector2 topRight    = (right.x, top.y);
      Vector2 bottomLeft  = (left.x,  bottom.y);
      Vector2 bottomRight = (right.x, bottom.y);

      switch (settings.frameStyle)
      {
        case settings.FRAME_DISABLED:
          break;

        case settings.FRAME_SLASH:
          drawCleanText(topLeft,     "/", f, color);
          drawCleanText(bottomRight, "/", f, color);
          break;

        case settings.FRAME_DOTS:
          drawCleanText(topLeft,     ".", f, color);
          drawCleanText(topRight,    ".", f, color);
          drawCleanText(bottomLeft,  ".", f, color);
          drawCleanText(bottomRight, ".", f, color);
          break;

        case settings.FRAME_LESS_GREATER:
          drawCleanText(left,  "<", f, color);
          drawCleanText(right, ">", f, color);
          break;

        case settings.FRAME_GREATER_LESS:
          drawCleanText(left,  ">", f, color);
          drawCleanText(right, "<", f, color);
          break;

        case settings.FRAME_BARS:
          drawCleanText(top,    ".", f, color);
          drawCleanText(left,   "I", f, color);
          drawCleanText(right,  "I", f, color);
          drawCleanText(bottom, ".", f, color);
          break;

        case settings.FRAME_GRAPHIC:
          {
            TextureID topLeftTex     = TexMan.CheckForTexture("ts_frame"              , TexMan.TryAny);
            TextureID topRightTex    = TexMan.CheckForTexture("ts_frame_top_right"    , TexMan.TryAny);
            TextureID bottomLeftTex  = TexMan.CheckForTexture("ts_frame_bottom_left"  , TexMan.TryAny);
            TextureID bottomRightTex = TexMan.CheckForTexture("ts_frame_bottom_right" , TexMan.TryAny);
            bool      animate        = false;
            Screen.SetClipRect( int(topLeft.x)
                              , int(topLeft.y)
                              , int(round(bottomRight.x - topLeft.x + 1))
                              , int(round(bottomRight.y - topLeft.y + 1))
                              );
            Screen.DrawTexture(topLeftTex,     animate, topLeft.x,     topLeft.y    );
            Screen.DrawTexture(topRightTex,    animate, topRight.x,    topRight.y   );
            Screen.DrawTexture(bottomLeftTex,  animate, bottomLeft.x,  bottomLeft.y );
            Screen.DrawTexture(bottomRightTex, animate, bottomRight.x, bottomRight.y);
            Screen.ClearClipRect();
          }
          break;
      }
    }
  }

  private ui static double round(double value)
  {
    return int(value + 1.0);
  }

  private ui void drawCleanText(Vector2 pos, string str, Font f, int color)
  {
    Screen.drawText( f
                   , color
                   , pos.x - (f.stringWidth(str) * cleanXFac / 2.0)
                   , pos.y - (f.getHeight()      * cleanYFac / 2.0)
                   , str
                   , DTA_CleanNoMove
                   , true
                   );
  }

  // Wrapper to access lastTarget in scope play from ui scope.
  // not really const, but lastTarget doesn't affect gameplay.
  private void SetLastTarget(Actor newLastTarget, int playerNumber) const
  {
    multiLastTargetInfo.get(playerNumber).a = newLastTarget;
  }

  play bool isSlot1Weapon(int playerNumber) const
  {
    PlayerInfo player = players[playerNumber];
    Weapon w = player.readyWeapon;
    if (w == null) { return true; }

    int located;
    int slot;
    int priority;
    [located, slot, priority] = player.weapons.LocateWeapon(w.GetClassName());
    return (slot == 1);
  }

  private ui void drawCrosshairs( Actor target
                                , int   crosshairColor
                                , Font  font
                                , int   playerNumber
                                )
  {
    let settings = multiSettings.get(playerNumber);

    if (!settings.crossOn) { return; }

    if (settings.noCrossOnSlot1
        && isSlot1Weapon(playerNumber))
    {
      return;
    }

    if (settings.hitConfirmation)
    {
      let lastTargetInfo = multiLastTargetInfo.get(playerNumber);
      if (lastTargetInfo.hurtTime != -1
          && (level.time < lastTargetInfo.hurtTime + 10))
      {
        crosshairColor = settings.hitColor;
      }
    }

    double scale           = 0.5 / settings.crossScale;
    int    x, y, width, height;
    [x, y, width, height]  = Screen.GetViewWindow();
    int    screenHeight    = Screen.GetHeight();
    int    statusBarHeight = screenHeight - height - x;
    double relativeStatusBarHeight = double(statusBarHeight) * scale / screenHeight;
    double baseCenterY     = 0.51 - relativeStatusBarHeight;
    double topBottomShift  = 0.02;

    double topY            = baseCenterY - topBottomShift + settings.topOff;
    double centerY         = baseCenterY                  + settings.crossOff;
    double bottomY         = baseCenterY + topBottomShift + settings.botOff;
    double dx              = settings.xAdjustment;

    drawTextCenter(settings.crossTop,  crosshairColor, scale, topY   , font, dx);
    drawTextCenter(settings.crosshair, crosshairColor, scale, centerY, font, dx);
    drawTextCenter(settings.crossBot,  crosshairColor, scale, bottomY, font, dx);
  }

  private ui void draw(Actor target, int playerNumber, RenderEvent event)
  {
    double y       = multiSettings.get(playerNumber).yStart;
    double newline = 0.03 * multiSettings.get(playerNumber).stepMult;
    if (y >= 0.80) { newline = -newline; }

    Font font      = Font.GetFont(multiSettings.get(playerNumber).fontName);
    Font crossfont = Font.GetFont(multiSettings.get(playerNumber).crossFontName);

    y = drawKillConfirmed(y, newline, font, playerNumber);

    PlayerInfo player    = players[playerNumber];
    bool       hasTarget = (target != null);
    int        crossCol  = multiSettings.get(playerNumber).crossCol;

    if (!hasTarget)
    {
      drawCrosshairs(target, crossCol, crossFont, playerNumber);
      return;
    }

    let    settings        = multiSettings.get(playerNumber);
    int    targetMaxHealth = GetActorMaxHealth(target);
    bool   showHealth      = (targetMaxHealth != 0);
    string legendaryToken  = "LDLegendaryMonsterToken";

    if (target.CountInv(legendaryToken) > 0)
    {
      targetMaxHealth *= 3;
    }

    if (targetMaxHealth < settings.minHealth && targetMaxHealth != 0)
      {
        drawCrosshairs(target, crossCol, crossFont, playerNumber);
        return; // not worth showing
      }

    int targetHealth = target.health;
    if (targetHealth < 1 && !settings.showCorps) // target is dead
      {
        drawCrosshairs(target, crossCol, crossFont, playerNumber);
        return;
      }

    int tagColor;
    if (targetMaxHealth < 100) { tagColor = settings.weakCol; }
    else                       { tagColor = settings.nameCol; }
    int customColor = CustomTargetColor(target);
    if (customColor)           { tagColor = customColor; }

    int percent = 10;
    if (showHealth)
      {
        if (targetHealth > targetMaxHealth) { percent = 11; }
        else { percent = targetHealth * 10 / targetMaxHealth; }
      }

    if (percent < 0) { percent = 0; }
    int targetColor = settings.colors[percent];
    if (targetHealth < 35 && settings.almDeadCr) targetColor = settings.crAlmDead;
    if (targetHealth < 1)                        targetColor = settings.crAlmDead;

    drawCrosshairs(target, targetColor, crossFont, playerNumber);

    double textScale = 0.5 / settings.textScale;

    if (settings.showBar && showHealth)
      {
        string hpBar = MakeHpBar(targetHealth, targetMaxHealth,
                                 settings.logScale,
                                 settings.pipSource, settings.emptyPipSource,
                                 settings.altHpCols,
                                 settings.greenCr, settings.redCr);
        drawTextCenter(hpBar, targetColor, textScale, y, font);
        y += newline;
      }

    int nameColor = tagColor;
    if (targetHealth < 1) { nameColor = targetColor; }

    if (settings.showName)
      {
        string targetName = GetTargetName(target, dehackedGameType, playerNumber);
        if (targetHealth < 1)
          {
            targetName = StringStruct.Format("Remains of %s", targetName);
            nameColor  = targetColor;
          }

        drawTextCenter(targetName, nameColor, textScale, y, font);
        y += newline;
      }

    if (settings.showInfo)
      {
        string targetFlags = GetTargetFlags(target);
        if (targetFlags.Length() > 0)
          {
            drawTextCenter(targetFlags, nameColor, textScale, y, font);
            y += newline;
          }
      }

    if (showHealth)
    {
      switch (settings.showNums)
      {
        case 0: break;

        case 1:
          drawTextCenter(StringStruct.Format("%d/%d",
                                             targetHealth, targetMaxHealth),
                         targetColor, textScale, y, font);
          y += newline;
          break;

        case 2:
          drawTextCenter(StringStruct.Format("%d", targetHealth),
                         targetColor, textScale, y, font);
          y += newline;
          break;

        case 3:
          int percent100;
          if (targetMaxHealth == 0) { percent100 = 100; }
          else { percent100 = targetHealth * 100 / targetMaxHealth; }

          drawTextCenter(StringStruct.Format("%d%", percent100),
                         targetColor, textScale, y, font);
          y += newline;
          break;
      }
    }

    if (settings.frameStyle != settings.FRAME_DISABLED)
    {
      drawFrame(event, playerNumber, target, targetColor);
    }
  }

  private ui double drawKillConfirmed( double y
                                     , double newline
                                     , Font   font
                                     , int    playerNumber
                                     )
  {
    if (!multiSettings.get(playerNumber).showKillConfirmation) { return y; }
    let lastTargetInfo = multiLastTargetInfo.get(playerNumber);
    if (lastTargetInfo.killTime == -1) { return y; }
    if (level.time < lastTargetInfo.killTime + 35 * 1)
      {
        double scale = 0.5 / multiSettings.get(playerNumber).textScale;
        drawTextCenter("Kill Confirmed", multiSettings.get(playerNumber).nameCol, scale, y, font);
        y += newline;
      }
    return y;
  }

  private ui void drawTextCenter( string text
                                , int    color
                                , double scale
                                , double relativeY
                                , Font   font
                                , double xAdjustment = 0
                                )
  {
    int width    = int(scale * Screen.GetWidth());
    int height   = int(scale * (Screen.GetHeight() - font.GetHeight()));
    int position = width - font.StringWidth(text);

    double x = position * 0.5 + xAdjustment;
    double y = height   * relativeY;

    Screen.DrawText(font, color, x, y, text,
                    DTA_KeepRatio,     true,
                    DTA_VirtualWidth,  width,
                    DTA_VirtualHeight, height);
  }

  private ui Actor GetTarget(int playerNumber, int gameType)
  {
    PlayerInfo player = players[playerNumber];
    if (!player) { return null; }
    Actor playerActor = player.mo;
    if (!playerActor) { return null; }

    // try an easy way to get a target (also works with autoaim)
    Actor target   = translator.AimTargetWrapper(player.mo);
    let   settings = multiSettings.get(playerNumber);

    // if target is not found by easy way, try the difficult way
    if (target == null)
    {
      target = translator.LineAttackTargetWrapper(player.mo, player.viewheight);
    }

    if (target == null && settings.showObjects > 1)
    {
      target = translator.AimLineAttackWrapper(player.mo);
    }

    // give up
    if (target == null) { return null; }

    // target is found

    // check sector lighting
    if (settings.hideInDarkness)
    {
      bool noLightAmplifier = (playerActor.FindInventory("PowerLightAmp") == null)
        && (playerActor.FindInventory("PowerInvulnerable") == null);
      if (noLightAmplifier)
      {
        Sector targetSector = target.curSector;
        int    lightlevel   = targetSector.lightlevel;
        if (lightLevel < settings.minimalLightLevel) { return null; }
      }
    }

    string targetClass   = target.GetClassName();
    bool   targetIsSlave = data.slaveActors.contains(targetClass);
    if (targetIsSlave)
    {
      target      = target.Master;
      targetClass = target.GetClassName();
    }

    bool isInBlackList = data.blackList.contains(targetClass);
    if (isInBlackList) { return null; }

    switch (gameType)
      {
      case 1: targetClass.AppendFormat("_free" ); break; // Freedoom
      case 2: targetClass.AppendFormat("_rekkr"); break; // Rekkr
      }

    // everything without name in REKKR is "blacklisted"
    if (targetClass.IndexOf("_rekkr") != -1)
      {
        string specialName = data.specialNames.get(targetClass);
        if (specialName.length() == 0) { return null; }
      }

    if (target.bISMONSTER)
      {
        bool targetIsHidden = (target.bSHADOW || target.bSTEALTH);
        if (!settings.showHidden  && targetIsHidden)   { return null; }
        if (!settings.showFriends && target.bFRIENDLY) { return null; }
        if (!settings.showIdle    && IsIdle(target))   { return null; }
      }
    else // not monsters
      {
        if (target.player) { return target; }

        switch (settings.showObjects)
          {
          case 0: return null;
          case 1:
            if (target.bSHOOTABLE) { return target; }
            else                   { return null;   }
          case 2:
            if (target.bSHOOTABLE || target is "Inventory") { return target; }
            else                                            { return null;   }
          case 3:
            return target;
          }
      }

    return target;
  }

  private ui bool IsIdle(Actor a) const
  {
    return a.target == null;
  }

  private ui int GetActorMaxHealth(Actor a)
  {
    if (a == null)     { return 0; }
    if (!a.bSHOOTABLE) { return 0; }

    if (a.player && a.player.mo) { return a.player.mo.GetMaxHealth(); }

    int maxHealth = a.SpawnHealth();
    return maxHealth;
  }

  private ui int CustomTargetColor(Actor target)
  {
    string customColorTokenClass = "tr_color_token";
    int customColor = target.CountInv(customColorTokenClass);
    return customColor;
  }

  private ui string MakeHpBar( int    health
                             , int    maxHealth
                             , bool   logScale
                             , string pipSource
                             , string emptyPipSource
                             , bool   greenRedTheme
                             , int    greenColor
                             , int    redColor
                             )
  {
    int length;
    if      (logScale)          { length = int(Log(maxHealth)) * 2; }
    else if (maxHealth >= 2000) { length = 30; }
    else if (maxHealth >= 500)  { length = 20; }
    else                        { length = 10; }

    int pips;
    if (maxHealth < 1)
    {
      pips = 1;
    }
    else
    {
      pips = health * length / maxHealth;
      pips = clamp(pips, 1, length);
    }

    string pipColor;
    string emptyColor;
    if (greenRedTheme)
      {
        pipColor   = StringStruct.Format("\c%c", 97 + greenColor); // 'a'
        emptyColor = StringStruct.Format("\c%c", 97 + redColor);   // 'a'
      }
    else
      {
        pipColor   = "";
        emptyColor = "";
      }

    return StringStruct.Format("%s%s%s%s",
                               pipColor,   pipSource.Left(pips),
                               emptyColor, emptyPipSource.Left(length - pips));

  }

  private int GetDehackedGameType()
  {
    string checkString = StringTable.Localize("$E1TEXT");
    string rekkrString = "You've been through war.";
    bool   isRekkr     = (checkString.IndexOf(rekkrString) >= 0);
    if (isRekkr) { return 2; }

    string impName     = StringTable.Localize("$CC_IMP");
    bool   isFreedoom  = (impName == "serpentipede");
    if (isFreedoom) { return 1; }

    return 0;
  }

  private ui string GetTargetName(Actor target, int gameType, int playerNumber)
  {
    if (target.player) { return target.player.GetUserName(); }

    string targetClass = target.GetClassName();

    switch (multiSettings.get(playerNumber).showInternalNames)
      {
      case 0: break;
      case 1: return targetClass;
      case 2: return m8f_ts_String.Beautify(targetClass);
      }

    switch (gameType)
      {
      case 1: targetClass.AppendFormat("_free" ); break; // Freedoom
      case 2: targetClass.AppendFormat("_rekkr"); break; // Rekkr
      }

    // if target name was found before, just return it
    if (cache.cachedClass == targetClass)
      {
        return AddAdditionalInfo(target, cache.cachedTag, playerNumber);
      }

    // if target name is set via actor tag, return it
    string targetName = target.GetTag();
    if (targetName != targetClass && !(gameType != 0))
      {
        cache.SetCache(targetClass, targetName);
        return AddAdditionalInfo(target, targetName, playerNumber);
      }

    string specialName = data.specialNames.get(targetClass);
    if (specialName.Length() != 0)
      {
        targetName = specialName;
        cache.SetCache(targetClass, targetName);
        return AddAdditionalInfo(target, targetName, playerNumber);
      }

    // if target name is not found, compose tag from class name
    targetName = m8f_ts_String.Beautify(targetName);

    cache.SetCache(targetClass, targetName);
    return AddAdditionalInfo(target, targetName, playerNumber);
  }

  private ui string AddAdditionalInfo(Actor target, string name, int playerNumber)
  {
    Inventory inv = Inventory(target);
    if (inv)
      {
        int amount = inv.amount;
        if (amount == 1)
          {
            BasicArmorPickup armor = BasicArmorPickup(inv);
            if (armor) { amount = armor.SaveAmount; }
          }
        if (amount == 1) { return name; }
        else             { return StringStruct.Format("%s (%i)", name, amount); }
      }
    else
      {
        return PrependChampionColor(target, name, playerNumber);
      }
  }

  private ui string PrependChampionColor(Actor target, string name, int playerNumber)
  {
    if (!multiSettings.get(playerNumber).showChampion) { return name; }

    string tokenClass = "champion_Token";
    Inventory token = target.FindInventory(tokenClass, true);
    if (!token) { return name; }

    string tokenClassName = token.GetClassName();
    string championTag    = data.championTokens.get(tokenClassName);
    if (championTag.Length() == 0) { championTag = "Champion"; }

    championTag.AppendFormat(" %s", name);
    return championTag;
  }

  private static ui string GetTargetFlags(Actor target)
  {
    string result = "";

    if (target.bFRIENDLY && !target.player)
      {
        result = "Friendly";
      }

    if (target.bINVULNERABLE)
      {
        if (result.Length() > 0) { result.AppendFormat(" "); }
        result.AppendFormat("Invulnerable");
      }

    if (target.bBOSS)
      {
        if (result.Length() > 0) { result.AppendFormat(" "); }
        result.AppendFormat("Boss");
      }

    return result;
  }

} // class m8f_ts_EventHandler
